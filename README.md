# bmstu-falp

Получается лисп

# Защиты (defend.lsp)

## ЛР1

Устно, задачки по типу `(* * *)` и `,`, рекурсивный `setf`

## ЛР2

Устно, задачки про `funcall`

## ЛР3

Квадратное уравнение на `and/or`

## ЛР4

Аналог функции `zip` :  `(zip '((A A A) (B B B) (C C C))) -> ((A B C) (A B C) (A B C))`, нельзя использовать `mapcar`

## ЛР5

Написать свой `reverse`, реализовать свап двух элементов через рекурсию и задачка про мост и фонарик (посчитать оптимальное время)

## ЛР6-7

Привести матрицу к диагональному виду, в качестве типа матрицы использовать тип `array`. В задачке ещё реализована возможность проверки, а действительно ли матрица приводится к диагональному виду (результат `reduce` будет равен исходной матрице):
```lisp
(defvar MMM #2A(...))
(reduce #'mmul (list (eigen-m MMM) (diagonal MMM) (inv (eigen-m MMM))))
```
Но это не сработает, если есть кратные корни (там нереальное мета программирование по поиску ФСР начинается)
